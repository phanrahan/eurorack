
ADSR_0_1.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  00000b40  00000bd4  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         00000b40  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000039  00800102  00800102  00000bd6  2**0
                  ALLOC
  3 .comment      00000011  00000000  00000000  00000bd6  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  00000be8  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 00000168  00000000  00000000  00000c28  2**3
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000011bd  00000000  00000000  00000d90  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 00000861  00000000  00000000  00001f4d  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00000b3d  00000000  00000000  000027ae  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  000001e8  00000000  00000000  000032ec  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    000004f3  00000000  00000000  000034d4  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    0000031e  00000000  00000000  000039c7  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 00000018  00000000  00000000  00003ce5  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 34 00 	jmp	0x68	; 0x68 <__ctors_end>
   4:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   8:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
   c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  10:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  14:	0c 94 d3 04 	jmp	0x9a6	; 0x9a6 <__vector_5>
  18:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  1c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  20:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  24:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  28:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  2c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  30:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  34:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  38:	0c 94 b4 04 	jmp	0x968	; 0x968 <__vector_14>
  3c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  40:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  44:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  48:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  4c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  50:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  54:	0c 94 2e 04 	jmp	0x85c	; 0x85c <__vector_21>
  58:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  5c:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  60:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>
  64:	0c 94 51 00 	jmp	0xa2	; 0xa2 <__bad_interrupt>

00000068 <__ctors_end>:
  68:	11 24       	eor	r1, r1
  6a:	1f be       	out	0x3f, r1	; 63
  6c:	cf ef       	ldi	r28, 0xFF	; 255
  6e:	d8 e0       	ldi	r29, 0x08	; 8
  70:	de bf       	out	0x3e, r29	; 62
  72:	cd bf       	out	0x3d, r28	; 61

00000074 <__do_copy_data>:
  74:	11 e0       	ldi	r17, 0x01	; 1
  76:	a0 e0       	ldi	r26, 0x00	; 0
  78:	b1 e0       	ldi	r27, 0x01	; 1
  7a:	e0 e4       	ldi	r30, 0x40	; 64
  7c:	fb e0       	ldi	r31, 0x0B	; 11
  7e:	02 c0       	rjmp	.+4      	; 0x84 <__do_copy_data+0x10>
  80:	05 90       	lpm	r0, Z+
  82:	0d 92       	st	X+, r0
  84:	a2 30       	cpi	r26, 0x02	; 2
  86:	b1 07       	cpc	r27, r17
  88:	d9 f7       	brne	.-10     	; 0x80 <__do_copy_data+0xc>

0000008a <__do_clear_bss>:
  8a:	21 e0       	ldi	r18, 0x01	; 1
  8c:	a2 e0       	ldi	r26, 0x02	; 2
  8e:	b1 e0       	ldi	r27, 0x01	; 1
  90:	01 c0       	rjmp	.+2      	; 0x94 <.do_clear_bss_start>

00000092 <.do_clear_bss_loop>:
  92:	1d 92       	st	X+, r1

00000094 <.do_clear_bss_start>:
  94:	ab 33       	cpi	r26, 0x3B	; 59
  96:	b2 07       	cpc	r27, r18
  98:	e1 f7       	brne	.-8      	; 0x92 <.do_clear_bss_loop>
  9a:	0e 94 ee 04 	call	0x9dc	; 0x9dc <main>
  9e:	0c 94 9e 05 	jmp	0xb3c	; 0xb3c <_exit>

000000a2 <__bad_interrupt>:
  a2:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000000a6 <init_ports>:
}


void	init_ports(void)
{
	DDRB = 0x2E;
  a6:	8e e2       	ldi	r24, 0x2E	; 46
  a8:	84 b9       	out	0x04, r24	; 4
	DDRC = 0x00;		// all inputs of the ADC variety
  aa:	17 b8       	out	0x07, r1	; 7
	PORTD = 0xC0;		// pull ups on PD6 & 7
  ac:	80 ec       	ldi	r24, 0xC0	; 192
  ae:	8b b9       	out	0x0b, r24	; 11
	DDRD = 0x0F;		//PD0-3 outputs, rest inputs
  b0:	8f e0       	ldi	r24, 0x0F	; 15
  b2:	8a b9       	out	0x0a, r24	; 10
}
  b4:	08 95       	ret

000000b6 <process_adsr>:


void process_adsr(void)
{
  b6:	2f 92       	push	r2
  b8:	3f 92       	push	r3
  ba:	4f 92       	push	r4
  bc:	5f 92       	push	r5
  be:	6f 92       	push	r6
  c0:	7f 92       	push	r7
  c2:	8f 92       	push	r8
  c4:	9f 92       	push	r9
  c6:	af 92       	push	r10
  c8:	bf 92       	push	r11
  ca:	cf 92       	push	r12
  cc:	df 92       	push	r13
  ce:	ef 92       	push	r14
  d0:	ff 92       	push	r15
  d2:	0f 93       	push	r16
  d4:	1f 93       	push	r17
  d6:	cf 93       	push	r28
  d8:	df 93       	push	r29
  da:	cd b7       	in	r28, 0x3d	; 61
  dc:	de b7       	in	r29, 0x3e	; 62
  de:	60 97       	sbiw	r28, 0x10	; 16
  e0:	0f b6       	in	r0, 0x3f	; 63
  e2:	f8 94       	cli
  e4:	de bf       	out	0x3e, r29	; 62
  e6:	0f be       	out	0x3f, r0	; 63
  e8:	cd bf       	out	0x3d, r28	; 61
	static uint32_t		NextExpoAmt;
	//	static uint8_t		flgRetrigOld;
	//	uint16_t			index;
	cli();
  ea:	f8 94       	cli
	
	switch (thisADSR.state) {
  ec:	80 91 1f 01 	lds	r24, 0x011F	; 0x80011f <thisADSR+0x18>
  f0:	82 30       	cpi	r24, 0x02	; 2
  f2:	09 f4       	brne	.+2      	; 0xf6 <process_adsr+0x40>
  f4:	38 c1       	rjmp	.+624    	; 0x366 <process_adsr+0x2b0>
  f6:	e8 f4       	brcc	.+58     	; 0x132 <process_adsr+0x7c>
  f8:	81 30       	cpi	r24, 0x01	; 1
  fa:	09 f4       	brne	.+2      	; 0xfe <process_adsr+0x48>
  fc:	4e c0       	rjmp	.+156    	; 0x19a <process_adsr+0xe4>
			thisADSR.accum-=((NextExpoAmt/8)*18);
			thisADSR.curDac=thisADSR.accum*2;
			break;
		}
	}
	sei();
  fe:	78 94       	sei
}
 100:	60 96       	adiw	r28, 0x10	; 16
 102:	0f b6       	in	r0, 0x3f	; 63
 104:	f8 94       	cli
 106:	de bf       	out	0x3e, r29	; 62
 108:	0f be       	out	0x3f, r0	; 63
 10a:	cd bf       	out	0x3d, r28	; 61
 10c:	df 91       	pop	r29
 10e:	cf 91       	pop	r28
 110:	1f 91       	pop	r17
 112:	0f 91       	pop	r16
 114:	ff 90       	pop	r15
 116:	ef 90       	pop	r14
 118:	df 90       	pop	r13
 11a:	cf 90       	pop	r12
 11c:	bf 90       	pop	r11
 11e:	af 90       	pop	r10
 120:	9f 90       	pop	r9
 122:	8f 90       	pop	r8
 124:	7f 90       	pop	r7
 126:	6f 90       	pop	r6
 128:	5f 90       	pop	r5
 12a:	4f 90       	pop	r4
 12c:	3f 90       	pop	r3
 12e:	2f 90       	pop	r2
 130:	08 95       	ret
	static uint32_t		NextExpoAmt;
	//	static uint8_t		flgRetrigOld;
	//	uint16_t			index;
	cli();
	
	switch (thisADSR.state) {
 132:	83 30       	cpi	r24, 0x03	; 3
 134:	09 f4       	brne	.+2      	; 0x138 <process_adsr+0x82>
 136:	39 c2       	rjmp	.+1138   	; 0x5aa <__LOCK_REGION_LENGTH__+0x1aa>
 138:	84 30       	cpi	r24, 0x04	; 4
 13a:	09 f7       	brne	.-62     	; 0xfe <process_adsr+0x48>
			LED_RELEASE
		}
		break;

		case s_rel:
		if(flgShape) {
 13c:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <flgShape>
 140:	88 23       	and	r24, r24
 142:	09 f4       	brne	.+2      	; 0x146 <process_adsr+0x90>
 144:	6d c2       	rjmp	.+1242   	; 0x620 <__LOCK_REGION_LENGTH__+0x220>
			//linear processing
			if(thisADSR.accum <= (thisADSR.release)) {
 146:	40 91 17 01 	lds	r20, 0x0117	; 0x800117 <thisADSR+0x10>
 14a:	50 91 18 01 	lds	r21, 0x0118	; 0x800118 <thisADSR+0x11>
 14e:	60 91 19 01 	lds	r22, 0x0119	; 0x800119 <thisADSR+0x12>
 152:	70 91 1a 01 	lds	r23, 0x011A	; 0x80011a <thisADSR+0x13>
 156:	80 91 13 01 	lds	r24, 0x0113	; 0x800113 <thisADSR+0xc>
 15a:	90 91 14 01 	lds	r25, 0x0114	; 0x800114 <thisADSR+0xd>
 15e:	a0 91 15 01 	lds	r26, 0x0115	; 0x800115 <thisADSR+0xe>
 162:	b0 91 16 01 	lds	r27, 0x0116	; 0x800116 <thisADSR+0xf>
 166:	84 17       	cp	r24, r20
 168:	95 07       	cpc	r25, r21
 16a:	a6 07       	cpc	r26, r22
 16c:	b7 07       	cpc	r27, r23
 16e:	08 f4       	brcc	.+2      	; 0x172 <process_adsr+0xbc>
 170:	4e c2       	rjmp	.+1180   	; 0x60e <__LOCK_REGION_LENGTH__+0x20e>
			NextExpoAmt=((NextExpoAmt*3)/2);
			NextExpoAmt=NextExpoAmt;

			//if(thisADSR.accum <= EXPOEPSILON) {
			if((int32_t)thisADSR.accum<(NextExpoAmt+EXPOEPSILON)) {
				thisADSR.accum=0;
 172:	10 92 17 01 	sts	0x0117, r1	; 0x800117 <thisADSR+0x10>
 176:	10 92 18 01 	sts	0x0118, r1	; 0x800118 <thisADSR+0x11>
 17a:	10 92 19 01 	sts	0x0119, r1	; 0x800119 <thisADSR+0x12>
 17e:	10 92 1a 01 	sts	0x011A, r1	; 0x80011a <thisADSR+0x13>
				thisADSR.state=s_idle;
 182:	10 92 1f 01 	sts	0x011F, r1	; 0x80011f <thisADSR+0x18>
				LED_IDLE
 186:	8b b1       	in	r24, 0x0b	; 11
 188:	8f 60       	ori	r24, 0x0F	; 15
 18a:	8b b9       	out	0x0b, r24	; 11
				// use for cycle mode...
				EOC_HI;
 18c:	29 9a       	sbi	0x05, 1	; 5
				tmrEOC=0;
 18e:	10 92 23 01 	sts	0x0123, r1	; 0x800123 <tmrEOC>
				flgEOC=1;
 192:	81 e0       	ldi	r24, 0x01	; 1
 194:	80 93 21 01 	sts	0x0121, r24	; 0x800121 <flgEOC>
 198:	3a c0       	rjmp	.+116    	; 0x20e <process_adsr+0x158>
	switch (thisADSR.state) {
		case s_idle:
		break;
		
		case s_att:
		if(flgShape) {
 19a:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <flgShape>
 19e:	88 23       	and	r24, r24
 1a0:	09 f4       	brne	.+2      	; 0x1a4 <process_adsr+0xee>
 1a2:	6b c0       	rjmp	.+214    	; 0x27a <process_adsr+0x1c4>
			//linear processing
			if((int64_t)(0x7fffffff-(thisADSR.accum)) < (thisADSR.attack)) {
 1a4:	00 91 17 01 	lds	r16, 0x0117	; 0x800117 <thisADSR+0x10>
 1a8:	10 91 18 01 	lds	r17, 0x0118	; 0x800118 <thisADSR+0x11>
 1ac:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <thisADSR+0x12>
 1b0:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <thisADSR+0x13>
 1b4:	40 91 07 01 	lds	r20, 0x0107	; 0x800107 <thisADSR>
 1b8:	50 91 08 01 	lds	r21, 0x0108	; 0x800108 <thisADSR+0x1>
 1bc:	60 91 09 01 	lds	r22, 0x0109	; 0x800109 <thisADSR+0x2>
 1c0:	70 91 0a 01 	lds	r23, 0x010A	; 0x80010a <thisADSR+0x3>
 1c4:	8f ef       	ldi	r24, 0xFF	; 255
 1c6:	9f ef       	ldi	r25, 0xFF	; 255
 1c8:	af ef       	ldi	r26, 0xFF	; 255
 1ca:	bf e7       	ldi	r27, 0x7F	; 127
 1cc:	5c 01       	movw	r10, r24
 1ce:	6d 01       	movw	r12, r26
 1d0:	a0 1a       	sub	r10, r16
 1d2:	b1 0a       	sbc	r11, r17
 1d4:	c2 0a       	sbc	r12, r18
 1d6:	d3 0a       	sbc	r13, r19
 1d8:	96 01       	movw	r18, r12
 1da:	85 01       	movw	r16, r10
 1dc:	04 17       	cp	r16, r20
 1de:	15 07       	cpc	r17, r21
 1e0:	26 07       	cpc	r18, r22
 1e2:	37 07       	cpc	r19, r23
 1e4:	48 f5       	brcc	.+82     	; 0x238 <process_adsr+0x182>
				thisADSR.accum=0x7fffffff;
 1e6:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <thisADSR+0x10>
 1ea:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <thisADSR+0x11>
 1ee:	a0 93 19 01 	sts	0x0119, r26	; 0x800119 <thisADSR+0x12>
 1f2:	b0 93 1a 01 	sts	0x011A, r27	; 0x80011a <thisADSR+0x13>
			NextExpoAmt=0x7ffffff0;
			if(NextExpoAmt<0)
			NextExpoAmt=0x7ffffff0;
			if((0x7fffffff-(thisADSR.accum)) <= NextExpoAmt+EXPOEPSILON) {
				thisADSR.accum=0x7fffffff;
				if(flgAR) {
 1f6:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <flgAR>
 1fa:	88 23       	and	r24, r24
 1fc:	09 f4       	brne	.+2      	; 0x200 <process_adsr+0x14a>
 1fe:	96 c0       	rjmp	.+300    	; 0x32c <process_adsr+0x276>
					thisADSR.state=s_rel;
 200:	84 e0       	ldi	r24, 0x04	; 4
 202:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <thisADSR+0x18>
					LED_RELEASE
 206:	8b b1       	in	r24, 0x0b	; 11
 208:	8f 60       	ori	r24, 0x0F	; 15
 20a:	8b b9       	out	0x0b, r24	; 11
 20c:	5b 98       	cbi	0x0b, 3	; 11

			}
			
			else
			thisADSR.accum-=((NextExpoAmt/8)*18);
			thisADSR.curDac=thisADSR.accum*2;
 20e:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 212:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 216:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 21a:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 21e:	88 0f       	add	r24, r24
 220:	99 1f       	adc	r25, r25
 222:	aa 1f       	adc	r26, r26
 224:	bb 1f       	adc	r27, r27
 226:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <thisADSR+0x14>
 22a:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <thisADSR+0x15>
 22e:	a0 93 1d 01 	sts	0x011D, r26	; 0x80011d <thisADSR+0x16>
 232:	b0 93 1e 01 	sts	0x011E, r27	; 0x80011e <thisADSR+0x17>
			break;
 236:	63 cf       	rjmp	.-314    	; 0xfe <process_adsr+0x48>
					thisADSR.state=s_dec;
					LED_DECAY
				}
			}
			else
			thisADSR.accum+=((thisADSR.attack)/2);
 238:	80 91 07 01 	lds	r24, 0x0107	; 0x800107 <thisADSR>
 23c:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <thisADSR+0x1>
 240:	a0 91 09 01 	lds	r26, 0x0109	; 0x800109 <thisADSR+0x2>
 244:	b0 91 0a 01 	lds	r27, 0x010A	; 0x80010a <thisADSR+0x3>
 248:	40 91 17 01 	lds	r20, 0x0117	; 0x800117 <thisADSR+0x10>
 24c:	50 91 18 01 	lds	r21, 0x0118	; 0x800118 <thisADSR+0x11>
 250:	60 91 19 01 	lds	r22, 0x0119	; 0x800119 <thisADSR+0x12>
 254:	70 91 1a 01 	lds	r23, 0x011A	; 0x80011a <thisADSR+0x13>
 258:	b6 95       	lsr	r27
 25a:	a7 95       	ror	r26
 25c:	97 95       	ror	r25
 25e:	87 95       	ror	r24
 260:	84 0f       	add	r24, r20
 262:	95 1f       	adc	r25, r21
 264:	a6 1f       	adc	r26, r22
 266:	b7 1f       	adc	r27, r23
				tmrEOC=0;
				flgEOC=1;
				
			}
			else
			thisADSR.accum-=((thisADSR.release)/2);
 268:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <thisADSR+0x10>
 26c:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <thisADSR+0x11>
 270:	a0 93 19 01 	sts	0x0119, r26	; 0x800119 <thisADSR+0x12>
 274:	b0 93 1a 01 	sts	0x011A, r27	; 0x80011a <thisADSR+0x13>
 278:	ca cf       	rjmp	.-108    	; 0x20e <process_adsr+0x158>
			thisADSR.accum+=((thisADSR.attack)/2);
			thisADSR.curDac=thisADSR.accum*2;
		}
		else {
			//expo processing
			NextExpoAmt=(0x9fffffff-thisADSR.accum);
 27a:	80 90 17 01 	lds	r8, 0x0117	; 0x800117 <thisADSR+0x10>
 27e:	90 90 18 01 	lds	r9, 0x0118	; 0x800118 <thisADSR+0x11>
 282:	a0 90 19 01 	lds	r10, 0x0119	; 0x800119 <thisADSR+0x12>
 286:	b0 90 1a 01 	lds	r11, 0x011A	; 0x80011a <thisADSR+0x13>
			NextExpoAmt=NextExpoAmt/((rawAdcSum[0]*2)+8);
 28a:	20 91 30 01 	lds	r18, 0x0130	; 0x800130 <rawAdcSum>
 28e:	30 91 31 01 	lds	r19, 0x0131	; 0x800131 <rawAdcSum+0x1>
			thisADSR.accum+=((thisADSR.attack)/2);
			thisADSR.curDac=thisADSR.accum*2;
		}
		else {
			//expo processing
			NextExpoAmt=(0x9fffffff-thisADSR.accum);
 292:	6f ef       	ldi	r22, 0xFF	; 255
 294:	7f ef       	ldi	r23, 0xFF	; 255
 296:	8f ef       	ldi	r24, 0xFF	; 255
 298:	9f e9       	ldi	r25, 0x9F	; 159
 29a:	68 19       	sub	r22, r8
 29c:	79 09       	sbc	r23, r9
 29e:	8a 09       	sbc	r24, r10
 2a0:	9b 09       	sbc	r25, r11
			NextExpoAmt=NextExpoAmt/((rawAdcSum[0]*2)+8);
 2a2:	2c 5f       	subi	r18, 0xFC	; 252
 2a4:	3f 4f       	sbci	r19, 0xFF	; 255
 2a6:	22 0f       	add	r18, r18
 2a8:	33 1f       	adc	r19, r19
 2aa:	50 e0       	ldi	r21, 0x00	; 0
 2ac:	40 e0       	ldi	r20, 0x00	; 0
 2ae:	0e 94 31 05 	call	0xa62	; 0xa62 <__udivmodsi4>
			NextExpoAmt=NextExpoAmt*3;
 2b2:	a3 e0       	ldi	r26, 0x03	; 3
 2b4:	b0 e0       	ldi	r27, 0x00	; 0
 2b6:	0e 94 72 05 	call	0xae4	; 0xae4 <__muluhisi3>
			NextExpoAmt=NextExpoAmt/4;
 2ba:	dc 01       	movw	r26, r24
 2bc:	cb 01       	movw	r24, r22
 2be:	12 e0       	ldi	r17, 0x02	; 2
 2c0:	b6 95       	lsr	r27
 2c2:	a7 95       	ror	r26
 2c4:	97 95       	ror	r25
 2c6:	87 95       	ror	r24
 2c8:	1a 95       	dec	r17
 2ca:	d1 f7       	brne	.-12     	; 0x2c0 <process_adsr+0x20a>
 2cc:	80 93 02 01 	sts	0x0102, r24	; 0x800102 <__data_end>
 2d0:	90 93 03 01 	sts	0x0103, r25	; 0x800103 <__data_end+0x1>
 2d4:	a0 93 04 01 	sts	0x0104, r26	; 0x800104 <__data_end+0x2>
 2d8:	b0 93 05 01 	sts	0x0105, r27	; 0x800105 <__data_end+0x3>
			
			if(NextExpoAmt>0x7ffffff0)
			NextExpoAmt=0x7ffffff0;
			if(NextExpoAmt<0)
			NextExpoAmt=0x7ffffff0;
			if((0x7fffffff-(thisADSR.accum)) <= NextExpoAmt+EXPOEPSILON) {
 2dc:	00 91 17 01 	lds	r16, 0x0117	; 0x800117 <thisADSR+0x10>
 2e0:	10 91 18 01 	lds	r17, 0x0118	; 0x800118 <thisADSR+0x11>
 2e4:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <thisADSR+0x12>
 2e8:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <thisADSR+0x13>
 2ec:	44 24       	eor	r4, r4
 2ee:	4a 94       	dec	r4
 2f0:	54 2c       	mov	r5, r4
 2f2:	64 2c       	mov	r6, r4
 2f4:	4f e7       	ldi	r20, 0x7F	; 127
 2f6:	74 2e       	mov	r7, r20
 2f8:	53 01       	movw	r10, r6
 2fa:	42 01       	movw	r8, r4
 2fc:	80 1a       	sub	r8, r16
 2fe:	91 0a       	sbc	r9, r17
 300:	a2 0a       	sbc	r10, r18
 302:	b3 0a       	sbc	r11, r19
 304:	8c 01       	movw	r16, r24
 306:	9d 01       	movw	r18, r26
 308:	01 50       	subi	r16, 0x01	; 1
 30a:	11 09       	sbc	r17, r1
 30c:	2f 4f       	sbci	r18, 0xFF	; 255
 30e:	3f 4f       	sbci	r19, 0xFF	; 255
 310:	08 15       	cp	r16, r8
 312:	19 05       	cpc	r17, r9
 314:	2a 05       	cpc	r18, r10
 316:	3b 05       	cpc	r19, r11
 318:	88 f0       	brcs	.+34     	; 0x33c <process_adsr+0x286>
				thisADSR.accum=0x7fffffff;
 31a:	40 92 17 01 	sts	0x0117, r4	; 0x800117 <thisADSR+0x10>
 31e:	50 92 18 01 	sts	0x0118, r5	; 0x800118 <thisADSR+0x11>
 322:	60 92 19 01 	sts	0x0119, r6	; 0x800119 <thisADSR+0x12>
 326:	70 92 1a 01 	sts	0x011A, r7	; 0x80011a <thisADSR+0x13>
 32a:	65 cf       	rjmp	.-310    	; 0x1f6 <process_adsr+0x140>
				if(flgAR) {
					thisADSR.state=s_rel;
					LED_RELEASE
					} else {
					thisADSR.state=s_dec;
 32c:	82 e0       	ldi	r24, 0x02	; 2
 32e:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <thisADSR+0x18>
					LED_DECAY
 332:	8b b1       	in	r24, 0x0b	; 11
 334:	8f 60       	ori	r24, 0x0F	; 15
 336:	8b b9       	out	0x0b, r24	; 11
 338:	5a 98       	cbi	0x0b, 2	; 11
 33a:	69 cf       	rjmp	.-302    	; 0x20e <process_adsr+0x158>
				}
			}
			else
			thisADSR.accum+=NextExpoAmt;
 33c:	00 91 17 01 	lds	r16, 0x0117	; 0x800117 <thisADSR+0x10>
 340:	10 91 18 01 	lds	r17, 0x0118	; 0x800118 <thisADSR+0x11>
 344:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <thisADSR+0x12>
 348:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <thisADSR+0x13>
 34c:	08 0f       	add	r16, r24
 34e:	19 1f       	adc	r17, r25
 350:	2a 1f       	adc	r18, r26
 352:	3b 1f       	adc	r19, r27
 354:	00 93 17 01 	sts	0x0117, r16	; 0x800117 <thisADSR+0x10>
 358:	10 93 18 01 	sts	0x0118, r17	; 0x800118 <thisADSR+0x11>
 35c:	20 93 19 01 	sts	0x0119, r18	; 0x800119 <thisADSR+0x12>
 360:	30 93 1a 01 	sts	0x011A, r19	; 0x80011a <thisADSR+0x13>
 364:	54 cf       	rjmp	.-344    	; 0x20e <process_adsr+0x158>
		}
		
		break;
		
		case s_dec:
		if(flgShape) {
 366:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <flgShape>
 36a:	88 23       	and	r24, r24
 36c:	09 f4       	brne	.+2      	; 0x370 <process_adsr+0x2ba>
 36e:	7b c0       	rjmp	.+246    	; 0x466 <__LOCK_REGION_LENGTH__+0x66>
			//linear processing
			if(((int64_t)thisADSR.accum - (int64_t)(thisADSR.decay)) < thisADSR.sustain/2) {
 370:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 374:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 378:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 37c:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 380:	40 91 0b 01 	lds	r20, 0x010B	; 0x80010b <thisADSR+0x4>
 384:	50 91 0c 01 	lds	r21, 0x010C	; 0x80010c <thisADSR+0x5>
 388:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <thisADSR+0x6>
 38c:	70 91 0e 01 	lds	r23, 0x010E	; 0x80010e <thisADSR+0x7>
 390:	c0 90 0f 01 	lds	r12, 0x010F	; 0x80010f <thisADSR+0x8>
 394:	d0 90 10 01 	lds	r13, 0x0110	; 0x800110 <thisADSR+0x9>
 398:	e0 90 11 01 	lds	r14, 0x0111	; 0x800111 <thisADSR+0xa>
 39c:	f0 90 12 01 	lds	r15, 0x0112	; 0x800112 <thisADSR+0xb>
 3a0:	c9 82       	std	Y+1, r12	; 0x01
 3a2:	da 82       	std	Y+2, r13	; 0x02
 3a4:	eb 82       	std	Y+3, r14	; 0x03
 3a6:	fc 82       	std	Y+4, r15	; 0x04
 3a8:	5c 01       	movw	r10, r24
 3aa:	6d 01       	movw	r12, r26
 3ac:	e1 2c       	mov	r14, r1
 3ae:	f1 2c       	mov	r15, r1
 3b0:	87 01       	movw	r16, r14
 3b2:	89 87       	std	Y+9, r24	; 0x09
 3b4:	ba 86       	std	Y+10, r11	; 0x0a
 3b6:	ab 87       	std	Y+11, r26	; 0x0b
 3b8:	dc 86       	std	Y+12, r13	; 0x0c
 3ba:	ed 86       	std	Y+13, r14	; 0x0d
 3bc:	fe 86       	std	Y+14, r15	; 0x0e
 3be:	0f 87       	std	Y+15, r16	; 0x0f
 3c0:	18 8b       	std	Y+16, r17	; 0x10
 3c2:	1a 01       	movw	r2, r20
 3c4:	2b 01       	movw	r4, r22
 3c6:	9c 01       	movw	r18, r24
 3c8:	ad 01       	movw	r20, r26
 3ca:	60 e0       	ldi	r22, 0x00	; 0
 3cc:	70 e0       	ldi	r23, 0x00	; 0
 3ce:	80 e0       	ldi	r24, 0x00	; 0
 3d0:	90 e0       	ldi	r25, 0x00	; 0
 3d2:	51 01       	movw	r10, r2
 3d4:	62 01       	movw	r12, r4
 3d6:	e1 2c       	mov	r14, r1
 3d8:	f1 2c       	mov	r15, r1
 3da:	00 e0       	ldi	r16, 0x00	; 0
 3dc:	10 e0       	ldi	r17, 0x00	; 0
 3de:	0e 94 7d 05 	call	0xafa	; 0xafa <__subdi3>
 3e2:	29 80       	ldd	r2, Y+1	; 0x01
 3e4:	3a 80       	ldd	r3, Y+2	; 0x02
 3e6:	4b 80       	ldd	r4, Y+3	; 0x03
 3e8:	5c 80       	ldd	r5, Y+4	; 0x04
 3ea:	56 94       	lsr	r5
 3ec:	47 94       	ror	r4
 3ee:	37 94       	ror	r3
 3f0:	27 94       	ror	r2
 3f2:	51 01       	movw	r10, r2
 3f4:	62 01       	movw	r12, r4
 3f6:	0e 94 86 05 	call	0xb0c	; 0xb0c <__cmpdi2>
 3fa:	e4 f4       	brge	.+56     	; 0x434 <__LOCK_REGION_LENGTH__+0x34>
				thisADSR.accum=thisADSR.sustain/2;
 3fc:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <thisADSR+0x8>
 400:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <thisADSR+0x9>
 404:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <thisADSR+0xa>
 408:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <thisADSR+0xb>
 40c:	b6 95       	lsr	r27
 40e:	a7 95       	ror	r26
 410:	97 95       	ror	r25
 412:	87 95       	ror	r24
			NextExpoAmt=NextExpoAmt/((rawAdcSum[1]*3)+12);
			NextExpoAmt=((NextExpoAmt*12)/10);
			NextExpoAmt=NextExpoAmt;

			if((int64_t)thisADSR.accum-((thisADSR.sustain/2)+EXPOEPSILON)<NextExpoAmt) {
				thisADSR.accum-=NextExpoAmt*2;
 414:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <thisADSR+0x10>
 418:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <thisADSR+0x11>
 41c:	a0 93 19 01 	sts	0x0119, r26	; 0x800119 <thisADSR+0x12>
 420:	b0 93 1a 01 	sts	0x011A, r27	; 0x80011a <thisADSR+0x13>
				thisADSR.state=s_sus;
 424:	83 e0       	ldi	r24, 0x03	; 3
 426:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <thisADSR+0x18>
				LED_SUSTAIN
 42a:	8b b1       	in	r24, 0x0b	; 11
 42c:	8f 60       	ori	r24, 0x0F	; 15
 42e:	8b b9       	out	0x0b, r24	; 11
 430:	59 98       	cbi	0x0b, 1	; 11
 432:	ed ce       	rjmp	.-550    	; 0x20e <process_adsr+0x158>
				thisADSR.accum=thisADSR.sustain/2;
				thisADSR.state=s_sus;
				LED_SUSTAIN
			}
			else
			thisADSR.accum-=(thisADSR.decay/2);
 434:	40 91 0b 01 	lds	r20, 0x010B	; 0x80010b <thisADSR+0x4>
 438:	50 91 0c 01 	lds	r21, 0x010C	; 0x80010c <thisADSR+0x5>
 43c:	60 91 0d 01 	lds	r22, 0x010D	; 0x80010d <thisADSR+0x6>
 440:	70 91 0e 01 	lds	r23, 0x010E	; 0x80010e <thisADSR+0x7>
				tmrEOC=0;
				flgEOC=1;
				
			}
			else
			thisADSR.accum-=((thisADSR.release)/2);
 444:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 448:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 44c:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 450:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 454:	76 95       	lsr	r23
 456:	67 95       	ror	r22
 458:	57 95       	ror	r21
 45a:	47 95       	ror	r20
 45c:	84 1b       	sub	r24, r20
 45e:	95 0b       	sbc	r25, r21
 460:	a6 0b       	sbc	r26, r22
 462:	b7 0b       	sbc	r27, r23
 464:	01 cf       	rjmp	.-510    	; 0x268 <process_adsr+0x1b2>
			thisADSR.curDac=thisADSR.accum*2;
			//break;
			
			} else {
			//expo processing
			NextExpoAmt=(thisADSR.accum-(thisADSR.sustain/2));
 466:	60 91 17 01 	lds	r22, 0x0117	; 0x800117 <thisADSR+0x10>
 46a:	70 91 18 01 	lds	r23, 0x0118	; 0x800118 <thisADSR+0x11>
 46e:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <thisADSR+0x12>
 472:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <thisADSR+0x13>
 476:	40 90 0f 01 	lds	r4, 0x010F	; 0x80010f <thisADSR+0x8>
 47a:	50 90 10 01 	lds	r5, 0x0110	; 0x800110 <thisADSR+0x9>
 47e:	60 90 11 01 	lds	r6, 0x0111	; 0x800111 <thisADSR+0xa>
 482:	70 90 12 01 	lds	r7, 0x0112	; 0x800112 <thisADSR+0xb>
			NextExpoAmt=NextExpoAmt/((rawAdcSum[1]*3)+12);
 486:	40 91 32 01 	lds	r20, 0x0132	; 0x800132 <rawAdcSum+0x2>
 48a:	50 91 33 01 	lds	r21, 0x0133	; 0x800133 <rawAdcSum+0x3>
			thisADSR.curDac=thisADSR.accum*2;
			//break;
			
			} else {
			//expo processing
			NextExpoAmt=(thisADSR.accum-(thisADSR.sustain/2));
 48e:	76 94       	lsr	r7
 490:	67 94       	ror	r6
 492:	57 94       	ror	r5
 494:	47 94       	ror	r4
 496:	64 19       	sub	r22, r4
 498:	75 09       	sbc	r23, r5
 49a:	86 09       	sbc	r24, r6
 49c:	97 09       	sbc	r25, r7
			NextExpoAmt=NextExpoAmt/((rawAdcSum[1]*3)+12);
 49e:	9a 01       	movw	r18, r20
 4a0:	22 0f       	add	r18, r18
 4a2:	33 1f       	adc	r19, r19
 4a4:	24 0f       	add	r18, r20
 4a6:	35 1f       	adc	r19, r21
 4a8:	24 5f       	subi	r18, 0xF4	; 244
 4aa:	3f 4f       	sbci	r19, 0xFF	; 255
 4ac:	50 e0       	ldi	r21, 0x00	; 0
 4ae:	40 e0       	ldi	r20, 0x00	; 0
 4b0:	0e 94 31 05 	call	0xa62	; 0xa62 <__udivmodsi4>
			NextExpoAmt=((NextExpoAmt*12)/10);
 4b4:	ac e0       	ldi	r26, 0x0C	; 12
 4b6:	b0 e0       	ldi	r27, 0x00	; 0
 4b8:	0e 94 72 05 	call	0xae4	; 0xae4 <__muluhisi3>
 4bc:	2a e0       	ldi	r18, 0x0A	; 10
 4be:	30 e0       	ldi	r19, 0x00	; 0
 4c0:	40 e0       	ldi	r20, 0x00	; 0
 4c2:	50 e0       	ldi	r21, 0x00	; 0
 4c4:	0e 94 31 05 	call	0xa62	; 0xa62 <__udivmodsi4>
 4c8:	29 01       	movw	r4, r18
 4ca:	3a 01       	movw	r6, r20
 4cc:	40 92 02 01 	sts	0x0102, r4	; 0x800102 <__data_end>
 4d0:	50 92 03 01 	sts	0x0103, r5	; 0x800103 <__data_end+0x1>
 4d4:	60 92 04 01 	sts	0x0104, r6	; 0x800104 <__data_end+0x2>
 4d8:	70 92 05 01 	sts	0x0105, r7	; 0x800105 <__data_end+0x3>
			NextExpoAmt=NextExpoAmt;

			if((int64_t)thisADSR.accum-((thisADSR.sustain/2)+EXPOEPSILON)<NextExpoAmt) {
 4dc:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 4e0:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 4e4:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 4e8:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 4ec:	40 91 0f 01 	lds	r20, 0x010F	; 0x80010f <thisADSR+0x8>
 4f0:	50 91 10 01 	lds	r21, 0x0110	; 0x800110 <thisADSR+0x9>
 4f4:	60 91 11 01 	lds	r22, 0x0111	; 0x800111 <thisADSR+0xa>
 4f8:	70 91 12 01 	lds	r23, 0x0112	; 0x800112 <thisADSR+0xb>
 4fc:	6c 01       	movw	r12, r24
 4fe:	7d 01       	movw	r14, r26
 500:	00 e0       	ldi	r16, 0x00	; 0
 502:	10 e0       	ldi	r17, 0x00	; 0
 504:	98 01       	movw	r18, r16
 506:	89 87       	std	Y+9, r24	; 0x09
 508:	da 86       	std	Y+10, r13	; 0x0a
 50a:	ab 87       	std	Y+11, r26	; 0x0b
 50c:	fc 86       	std	Y+12, r15	; 0x0c
 50e:	0d 87       	std	Y+13, r16	; 0x0d
 510:	1e 87       	std	Y+14, r17	; 0x0e
 512:	2f 87       	std	Y+15, r18	; 0x0f
 514:	38 8b       	std	Y+16, r19	; 0x10
 516:	76 95       	lsr	r23
 518:	67 95       	ror	r22
 51a:	57 95       	ror	r21
 51c:	47 95       	ror	r20
 51e:	41 50       	subi	r20, 0x01	; 1
 520:	51 09       	sbc	r21, r1
 522:	6f 4f       	sbci	r22, 0xFF	; 255
 524:	7f 4f       	sbci	r23, 0xFF	; 255
 526:	5a 01       	movw	r10, r20
 528:	6b 01       	movw	r12, r22
 52a:	29 85       	ldd	r18, Y+9	; 0x09
 52c:	3a 85       	ldd	r19, Y+10	; 0x0a
 52e:	4b 85       	ldd	r20, Y+11	; 0x0b
 530:	5c 85       	ldd	r21, Y+12	; 0x0c
 532:	60 e0       	ldi	r22, 0x00	; 0
 534:	70 e0       	ldi	r23, 0x00	; 0
 536:	80 e0       	ldi	r24, 0x00	; 0
 538:	90 e0       	ldi	r25, 0x00	; 0
 53a:	e1 2c       	mov	r14, r1
 53c:	f1 2c       	mov	r15, r1
 53e:	00 e0       	ldi	r16, 0x00	; 0
 540:	10 e0       	ldi	r17, 0x00	; 0
 542:	0e 94 7d 05 	call	0xafa	; 0xafa <__subdi3>
 546:	63 01       	movw	r12, r6
 548:	52 01       	movw	r10, r4
 54a:	e1 2c       	mov	r14, r1
 54c:	f1 2c       	mov	r15, r1
 54e:	87 01       	movw	r16, r14
 550:	49 82       	std	Y+1, r4	; 0x01
 552:	ba 82       	std	Y+2, r11	; 0x02
 554:	6b 82       	std	Y+3, r6	; 0x03
 556:	dc 82       	std	Y+4, r13	; 0x04
 558:	ed 82       	std	Y+5, r14	; 0x05
 55a:	fe 82       	std	Y+6, r15	; 0x06
 55c:	0f 83       	std	Y+7, r16	; 0x07
 55e:	18 87       	std	Y+8, r17	; 0x08
 560:	e1 2c       	mov	r14, r1
 562:	f1 2c       	mov	r15, r1
 564:	00 e0       	ldi	r16, 0x00	; 0
 566:	10 e0       	ldi	r17, 0x00	; 0
 568:	44 0c       	add	r4, r4
 56a:	55 1c       	adc	r5, r5
 56c:	66 1c       	adc	r6, r6
 56e:	77 1c       	adc	r7, r7
 570:	0e 94 86 05 	call	0xb0c	; 0xb0c <__cmpdi2>
 574:	6c f4       	brge	.+26     	; 0x590 <__LOCK_REGION_LENGTH__+0x190>
				thisADSR.accum-=NextExpoAmt*2;
 576:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 57a:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 57e:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 582:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 586:	84 19       	sub	r24, r4
 588:	95 09       	sbc	r25, r5
 58a:	a6 09       	sbc	r26, r6
 58c:	b7 09       	sbc	r27, r7
 58e:	42 cf       	rjmp	.-380    	; 0x414 <__LOCK_REGION_LENGTH__+0x14>
				thisADSR.state=s_sus;
				LED_SUSTAIN
			}
			else
			thisADSR.accum-=NextExpoAmt*2;
 590:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 594:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 598:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 59c:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 5a0:	84 19       	sub	r24, r4
 5a2:	95 09       	sbc	r25, r5
 5a4:	a6 09       	sbc	r26, r6
 5a6:	b7 09       	sbc	r27, r7
 5a8:	5f ce       	rjmp	.-834    	; 0x268 <process_adsr+0x1b2>
		}

		break;
		
		case s_sus:
		thisADSR.accum=thisADSR.sustain/2;
 5aa:	80 91 0f 01 	lds	r24, 0x010F	; 0x80010f <thisADSR+0x8>
 5ae:	90 91 10 01 	lds	r25, 0x0110	; 0x800110 <thisADSR+0x9>
 5b2:	a0 91 11 01 	lds	r26, 0x0111	; 0x800111 <thisADSR+0xa>
 5b6:	b0 91 12 01 	lds	r27, 0x0112	; 0x800112 <thisADSR+0xb>
 5ba:	b6 95       	lsr	r27
 5bc:	a7 95       	ror	r26
 5be:	97 95       	ror	r25
 5c0:	87 95       	ror	r24
 5c2:	80 93 17 01 	sts	0x0117, r24	; 0x800117 <thisADSR+0x10>
 5c6:	90 93 18 01 	sts	0x0118, r25	; 0x800118 <thisADSR+0x11>
 5ca:	a0 93 19 01 	sts	0x0119, r26	; 0x800119 <thisADSR+0x12>
 5ce:	b0 93 1a 01 	sts	0x011A, r27	; 0x80011a <thisADSR+0x13>
		thisADSR.curDac=thisADSR.accum*2;
 5d2:	80 91 17 01 	lds	r24, 0x0117	; 0x800117 <thisADSR+0x10>
 5d6:	90 91 18 01 	lds	r25, 0x0118	; 0x800118 <thisADSR+0x11>
 5da:	a0 91 19 01 	lds	r26, 0x0119	; 0x800119 <thisADSR+0x12>
 5de:	b0 91 1a 01 	lds	r27, 0x011A	; 0x80011a <thisADSR+0x13>
 5e2:	88 0f       	add	r24, r24
 5e4:	99 1f       	adc	r25, r25
 5e6:	aa 1f       	adc	r26, r26
 5e8:	bb 1f       	adc	r27, r27
 5ea:	80 93 1b 01 	sts	0x011B, r24	; 0x80011b <thisADSR+0x14>
 5ee:	90 93 1c 01 	sts	0x011C, r25	; 0x80011c <thisADSR+0x15>
 5f2:	a0 93 1d 01 	sts	0x011D, r26	; 0x80011d <thisADSR+0x16>
 5f6:	b0 93 1e 01 	sts	0x011E, r27	; 0x80011e <thisADSR+0x17>
		//if(PORTA.IN & PIN6_bm)
		if((PIND & 0x10)==0x10)	{					// is Gate went away i.e. high (inverted)
 5fa:	4c 9b       	sbis	0x09, 4	; 9
 5fc:	80 cd       	rjmp	.-1280   	; 0xfe <process_adsr+0x48>
			thisADSR.state=s_rel;						// jump to release state
 5fe:	84 e0       	ldi	r24, 0x04	; 4
 600:	80 93 1f 01 	sts	0x011F, r24	; 0x80011f <thisADSR+0x18>
			LED_RELEASE
 604:	8b b1       	in	r24, 0x0b	; 11
 606:	8f 60       	ori	r24, 0x0F	; 15
 608:	8b b9       	out	0x0b, r24	; 11
 60a:	5b 98       	cbi	0x0b, 3	; 11
 60c:	78 cd       	rjmp	.-1296   	; 0xfe <process_adsr+0x48>
				tmrEOC=0;
				flgEOC=1;
				
			}
			else
			thisADSR.accum-=((thisADSR.release)/2);
 60e:	40 91 13 01 	lds	r20, 0x0113	; 0x800113 <thisADSR+0xc>
 612:	50 91 14 01 	lds	r21, 0x0114	; 0x800114 <thisADSR+0xd>
 616:	60 91 15 01 	lds	r22, 0x0115	; 0x800115 <thisADSR+0xe>
 61a:	70 91 16 01 	lds	r23, 0x0116	; 0x800116 <thisADSR+0xf>
 61e:	12 cf       	rjmp	.-476    	; 0x444 <__LOCK_REGION_LENGTH__+0x44>
			
			//process exp curve crap
			thisADSR.curDac=thisADSR.accum*2;
			} else {
			//process exp curve
			NextExpoAmt=thisADSR.accum;
 620:	60 91 17 01 	lds	r22, 0x0117	; 0x800117 <thisADSR+0x10>
 624:	70 91 18 01 	lds	r23, 0x0118	; 0x800118 <thisADSR+0x11>
 628:	80 91 19 01 	lds	r24, 0x0119	; 0x800119 <thisADSR+0x12>
 62c:	90 91 1a 01 	lds	r25, 0x011A	; 0x80011a <thisADSR+0x13>
			NextExpoAmt=NextExpoAmt/((rawAdcSum[3]*3)+12);
 630:	40 91 36 01 	lds	r20, 0x0136	; 0x800136 <rawAdcSum+0x6>
 634:	50 91 37 01 	lds	r21, 0x0137	; 0x800137 <rawAdcSum+0x7>
 638:	9a 01       	movw	r18, r20
 63a:	22 0f       	add	r18, r18
 63c:	33 1f       	adc	r19, r19
 63e:	24 0f       	add	r18, r20
 640:	35 1f       	adc	r19, r21
 642:	24 5f       	subi	r18, 0xF4	; 244
 644:	3f 4f       	sbci	r19, 0xFF	; 255
 646:	50 e0       	ldi	r21, 0x00	; 0
 648:	40 e0       	ldi	r20, 0x00	; 0
 64a:	0e 94 31 05 	call	0xa62	; 0xa62 <__udivmodsi4>
			NextExpoAmt=((NextExpoAmt*3)/2);
 64e:	a3 e0       	ldi	r26, 0x03	; 3
 650:	b0 e0       	ldi	r27, 0x00	; 0
 652:	0e 94 72 05 	call	0xae4	; 0xae4 <__muluhisi3>
 656:	2b 01       	movw	r4, r22
 658:	3c 01       	movw	r6, r24
 65a:	76 94       	lsr	r7
 65c:	67 94       	ror	r6
 65e:	57 94       	ror	r5
 660:	47 94       	ror	r4
 662:	40 92 02 01 	sts	0x0102, r4	; 0x800102 <__data_end>
 666:	50 92 03 01 	sts	0x0103, r5	; 0x800103 <__data_end+0x1>
 66a:	60 92 04 01 	sts	0x0104, r6	; 0x800104 <__data_end+0x2>
 66e:	70 92 05 01 	sts	0x0105, r7	; 0x800105 <__data_end+0x3>
			NextExpoAmt=NextExpoAmt;

			//if(thisADSR.accum <= EXPOEPSILON) {
			if((int32_t)thisADSR.accum<(NextExpoAmt+EXPOEPSILON)) {
 672:	00 91 17 01 	lds	r16, 0x0117	; 0x800117 <thisADSR+0x10>
 676:	10 91 18 01 	lds	r17, 0x0118	; 0x800118 <thisADSR+0x11>
 67a:	20 91 19 01 	lds	r18, 0x0119	; 0x800119 <thisADSR+0x12>
 67e:	30 91 1a 01 	lds	r19, 0x011A	; 0x80011a <thisADSR+0x13>
 682:	4f ef       	ldi	r20, 0xFF	; 255
 684:	44 0e       	add	r4, r20
 686:	54 1e       	adc	r5, r20
 688:	61 1c       	adc	r6, r1
 68a:	71 1c       	adc	r7, r1
 68c:	04 15       	cp	r16, r4
 68e:	15 05       	cpc	r17, r5
 690:	26 05       	cpc	r18, r6
 692:	37 05       	cpc	r19, r7
 694:	08 f4       	brcc	.+2      	; 0x698 <__LOCK_REGION_LENGTH__+0x298>
 696:	6d cd       	rjmp	.-1318   	; 0x172 <process_adsr+0xbc>
				flgEOC=1;

			}
			
			else
			thisADSR.accum-=((NextExpoAmt/8)*18);
 698:	40 90 17 01 	lds	r4, 0x0117	; 0x800117 <thisADSR+0x10>
 69c:	50 90 18 01 	lds	r5, 0x0118	; 0x800118 <thisADSR+0x11>
 6a0:	60 90 19 01 	lds	r6, 0x0119	; 0x800119 <thisADSR+0x12>
 6a4:	70 90 1a 01 	lds	r7, 0x011A	; 0x80011a <thisADSR+0x13>
 6a8:	9b 01       	movw	r18, r22
 6aa:	ac 01       	movw	r20, r24
 6ac:	64 e0       	ldi	r22, 0x04	; 4
 6ae:	56 95       	lsr	r21
 6b0:	47 95       	ror	r20
 6b2:	37 95       	ror	r19
 6b4:	27 95       	ror	r18
 6b6:	6a 95       	dec	r22
 6b8:	d1 f7       	brne	.-12     	; 0x6ae <__LOCK_REGION_LENGTH__+0x2ae>
 6ba:	a2 e1       	ldi	r26, 0x12	; 18
 6bc:	b0 e0       	ldi	r27, 0x00	; 0
 6be:	0e 94 72 05 	call	0xae4	; 0xae4 <__muluhisi3>
 6c2:	46 1a       	sub	r4, r22
 6c4:	57 0a       	sbc	r5, r23
 6c6:	68 0a       	sbc	r6, r24
 6c8:	79 0a       	sbc	r7, r25
 6ca:	40 92 17 01 	sts	0x0117, r4	; 0x800117 <thisADSR+0x10>
 6ce:	50 92 18 01 	sts	0x0118, r5	; 0x800118 <thisADSR+0x11>
 6d2:	60 92 19 01 	sts	0x0119, r6	; 0x800119 <thisADSR+0x12>
 6d6:	70 92 1a 01 	sts	0x011A, r7	; 0x80011a <thisADSR+0x13>
 6da:	99 cd       	rjmp	.-1230   	; 0x20e <process_adsr+0x158>

000006dc <init_devices>:
void init_devices(void)
{
	//
	// sets up ADC system
	//
	ADMUX = (1<<REFS0);		//AVCC as reference
 6dc:	80 e4       	ldi	r24, 0x40	; 64
 6de:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA = (1<<ADPS2)|(1<<ADPS1)|(1<<ADPS0)|(1<<ADEN);
 6e2:	87 e8       	ldi	r24, 0x87	; 135
 6e4:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>

	//
	// enable IRQ on Gate jack input
	PCMSK2 = (1<<PCINT20);		
 6e8:	80 e1       	ldi	r24, 0x10	; 16
 6ea:	80 93 6d 00 	sts	0x006D, r24	; 0x80006d <__TEXT_REGION_LENGTH__+0x7e006d>
	PCICR = (1<<PCIE2);						//enable interrupts
 6ee:	84 e0       	ldi	r24, 0x04	; 4
 6f0:	80 93 68 00 	sts	0x0068, r24	; 0x800068 <__TEXT_REGION_LENGTH__+0x7e0068>
	
	// ***SPI***
	SPCR = (1<<SPE)|(1<<MSTR)|(1<<SPR0);	// SPI enable	
 6f4:	81 e5       	ldi	r24, 0x51	; 81
 6f6:	8c bd       	out	0x2c, r24	; 44
}
 6f8:	08 95       	ret

000006fa <pgm_init>:


void pgm_init(void)
{
	// setup mux channel
	thisAdcChannel=0;
 6fa:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <thisAdcChannel>
	ADMUX |= thisAdcChannel;
 6fe:	ec e7       	ldi	r30, 0x7C	; 124
 700:	f0 e0       	ldi	r31, 0x00	; 0
 702:	80 81       	ld	r24, Z
 704:	80 83       	st	Z, r24
	LED_IDLE
 706:	8b b1       	in	r24, 0x0b	; 11
 708:	8f 60       	ori	r24, 0x0F	; 15
 70a:	8b b9       	out	0x0b, r24	; 11
	SS_HI;
 70c:	2a 9a       	sbi	0x05, 2	; 5
}
 70e:	08 95       	ret

00000710 <adcProcess>:


void adcProcess(void)
{
 710:	cf 92       	push	r12
 712:	df 92       	push	r13
 714:	ef 92       	push	r14
 716:	ff 92       	push	r15
 718:	0f 93       	push	r16
 71a:	1f 93       	push	r17
 71c:	cf 93       	push	r28
 71e:	df 93       	push	r29
	rawAdcSum[0]=rawAdcPots[0]+adsr_cv;
 720:	e7 e2       	ldi	r30, 0x27	; 39
 722:	f1 e0       	ldi	r31, 0x01	; 1
 724:	20 81       	ld	r18, Z
 726:	31 81       	ldd	r19, Z+1	; 0x01
 728:	80 91 38 01 	lds	r24, 0x0138	; 0x800138 <adsr_cv>
 72c:	90 91 39 01 	lds	r25, 0x0139	; 0x800139 <adsr_cv+0x1>
 730:	28 0f       	add	r18, r24
 732:	39 1f       	adc	r19, r25
 734:	c0 e3       	ldi	r28, 0x30	; 48
 736:	d1 e0       	ldi	r29, 0x01	; 1
 738:	39 83       	std	Y+1, r19	; 0x01
 73a:	28 83       	st	Y, r18
	rawAdcSum[1]=rawAdcPots[1]+adsr_cv;
 73c:	22 81       	ldd	r18, Z+2	; 0x02
 73e:	33 81       	ldd	r19, Z+3	; 0x03
 740:	28 0f       	add	r18, r24
 742:	39 1f       	adc	r19, r25
 744:	3b 83       	std	Y+3, r19	; 0x03
 746:	2a 83       	std	Y+2, r18	; 0x02
	rawAdcSum[2]=rawAdcPots[2];
 748:	24 81       	ldd	r18, Z+4	; 0x04
 74a:	35 81       	ldd	r19, Z+5	; 0x05
 74c:	3d 83       	std	Y+5, r19	; 0x05
 74e:	2c 83       	std	Y+4, r18	; 0x04
	rawAdcSum[3]=rawAdcPots[3]+adsr_cv+rel_cv;
 750:	26 81       	ldd	r18, Z+6	; 0x06
 752:	37 81       	ldd	r19, Z+7	; 0x07
 754:	82 0f       	add	r24, r18
 756:	93 1f       	adc	r25, r19
 758:	20 91 25 01 	lds	r18, 0x0125	; 0x800125 <rel_cv>
 75c:	30 91 26 01 	lds	r19, 0x0126	; 0x800126 <rel_cv+0x1>
 760:	82 0f       	add	r24, r18
 762:	93 1f       	adc	r25, r19
 764:	9f 83       	std	Y+7, r25	; 0x07
 766:	8e 83       	std	Y+6, r24	; 0x06
	
	thisADSR.attack=0x20000000/((rawAdcSum[0]+0x02)/0x02);
 768:	28 81       	ld	r18, Y
 76a:	39 81       	ldd	r19, Y+1	; 0x01
 76c:	2e 5f       	subi	r18, 0xFE	; 254
 76e:	3f 4f       	sbci	r19, 0xFF	; 255
 770:	36 95       	lsr	r19
 772:	27 95       	ror	r18
 774:	50 e0       	ldi	r21, 0x00	; 0
 776:	40 e0       	ldi	r20, 0x00	; 0
 778:	c1 2c       	mov	r12, r1
 77a:	d1 2c       	mov	r13, r1
 77c:	e1 2c       	mov	r14, r1
 77e:	90 e2       	ldi	r25, 0x20	; 32
 780:	f9 2e       	mov	r15, r25
 782:	c7 01       	movw	r24, r14
 784:	b6 01       	movw	r22, r12
 786:	0e 94 53 05 	call	0xaa6	; 0xaa6 <__divmodsi4>
 78a:	07 e0       	ldi	r16, 0x07	; 7
 78c:	11 e0       	ldi	r17, 0x01	; 1
 78e:	f8 01       	movw	r30, r16
 790:	20 83       	st	Z, r18
 792:	31 83       	std	Z+1, r19	; 0x01
 794:	42 83       	std	Z+2, r20	; 0x02
 796:	53 83       	std	Z+3, r21	; 0x03
	thisADSR.decay=0x20000000/((rawAdcSum[1]+0x02)/0x02);
 798:	2a 81       	ldd	r18, Y+2	; 0x02
 79a:	3b 81       	ldd	r19, Y+3	; 0x03
 79c:	2e 5f       	subi	r18, 0xFE	; 254
 79e:	3f 4f       	sbci	r19, 0xFF	; 255
 7a0:	36 95       	lsr	r19
 7a2:	27 95       	ror	r18
 7a4:	50 e0       	ldi	r21, 0x00	; 0
 7a6:	40 e0       	ldi	r20, 0x00	; 0
 7a8:	c7 01       	movw	r24, r14
 7aa:	b6 01       	movw	r22, r12
 7ac:	0e 94 53 05 	call	0xaa6	; 0xaa6 <__divmodsi4>
 7b0:	f8 01       	movw	r30, r16
 7b2:	24 83       	std	Z+4, r18	; 0x04
 7b4:	35 83       	std	Z+5, r19	; 0x05
 7b6:	46 83       	std	Z+6, r20	; 0x06
 7b8:	57 83       	std	Z+7, r21	; 0x07
	thisADSR.sustain=(uint32_t)rawAdcSum[2]<<22;
 7ba:	8c 81       	ldd	r24, Y+4	; 0x04
 7bc:	9d 81       	ldd	r25, Y+5	; 0x05
 7be:	b0 e0       	ldi	r27, 0x00	; 0
 7c0:	a0 e0       	ldi	r26, 0x00	; 0
 7c2:	56 e1       	ldi	r21, 0x16	; 22
 7c4:	88 0f       	add	r24, r24
 7c6:	99 1f       	adc	r25, r25
 7c8:	aa 1f       	adc	r26, r26
 7ca:	bb 1f       	adc	r27, r27
 7cc:	5a 95       	dec	r21
 7ce:	d1 f7       	brne	.-12     	; 0x7c4 <adcProcess+0xb4>
 7d0:	80 87       	std	Z+8, r24	; 0x08
 7d2:	91 87       	std	Z+9, r25	; 0x09
 7d4:	a2 87       	std	Z+10, r26	; 0x0a
 7d6:	b3 87       	std	Z+11, r27	; 0x0b
	thisADSR.release=0x20000000/((rawAdcSum[3]+0x02)/0x02);
 7d8:	2e 81       	ldd	r18, Y+6	; 0x06
 7da:	3f 81       	ldd	r19, Y+7	; 0x07
 7dc:	2e 5f       	subi	r18, 0xFE	; 254
 7de:	3f 4f       	sbci	r19, 0xFF	; 255
 7e0:	36 95       	lsr	r19
 7e2:	27 95       	ror	r18
 7e4:	50 e0       	ldi	r21, 0x00	; 0
 7e6:	40 e0       	ldi	r20, 0x00	; 0
 7e8:	c7 01       	movw	r24, r14
 7ea:	b6 01       	movw	r22, r12
 7ec:	0e 94 53 05 	call	0xaa6	; 0xaa6 <__divmodsi4>
 7f0:	f8 01       	movw	r30, r16
 7f2:	24 87       	std	Z+12, r18	; 0x0c
 7f4:	35 87       	std	Z+13, r19	; 0x0d
 7f6:	46 87       	std	Z+14, r20	; 0x0e
 7f8:	57 87       	std	Z+15, r21	; 0x0f
}
 7fa:	df 91       	pop	r29
 7fc:	cf 91       	pop	r28
 7fe:	1f 91       	pop	r17
 800:	0f 91       	pop	r16
 802:	ff 90       	pop	r15
 804:	ef 90       	pop	r14
 806:	df 90       	pop	r13
 808:	cf 90       	pop	r12
 80a:	08 95       	ret

0000080c <SendToShiftyTypes>:
void SendToShiftyTypes(void)
{
	uint8_t		dummy;
	uint16_t	sendVal;

	cli();
 80c:	f8 94       	cli
	SS_LO;
 80e:	2a 98       	cbi	0x05, 2	; 5
	
	sendVal = thisADSR.curDac>>20;
 810:	80 91 1b 01 	lds	r24, 0x011B	; 0x80011b <thisADSR+0x14>
 814:	90 91 1c 01 	lds	r25, 0x011C	; 0x80011c <thisADSR+0x15>
 818:	a0 91 1d 01 	lds	r26, 0x011D	; 0x80011d <thisADSR+0x16>
 81c:	b0 91 1e 01 	lds	r27, 0x011E	; 0x80011e <thisADSR+0x17>
 820:	24 e1       	ldi	r18, 0x14	; 20
 822:	b6 95       	lsr	r27
 824:	a7 95       	ror	r26
 826:	97 95       	ror	r25
 828:	87 95       	ror	r24
 82a:	2a 95       	dec	r18
 82c:	d1 f7       	brne	.-12     	; 0x822 <SendToShiftyTypes+0x16>
	sendVal = sendVal | 0x3000;			//gain=1,active mode
 82e:	90 63       	ori	r25, 0x30	; 48
	
	SPDR=sendVal>>8;					// send MSB
 830:	9e bd       	out	0x2e, r25	; 46
	do {} while (!(SPSR&(1<<SPIF)));
 832:	0d b4       	in	r0, 0x2d	; 45
 834:	07 fe       	sbrs	r0, 7
 836:	fd cf       	rjmp	.-6      	; 0x832 <SendToShiftyTypes+0x26>
	dummy=SPDR; 				//dummy read to clear flag
 838:	9e b5       	in	r25, 0x2e	; 46

	SPDR=sendVal&0x00FF;				// send LSB
 83a:	8e bd       	out	0x2e, r24	; 46
	do {} while (!(SPSR&(1<<SPIF)));
 83c:	0d b4       	in	r0, 0x2d	; 45
 83e:	07 fe       	sbrs	r0, 7
 840:	fd cf       	rjmp	.-6      	; 0x83c <SendToShiftyTypes+0x30>
	dummy=SPDR; 				//dummy read to clear flag
 842:	8e b5       	in	r24, 0x2e	; 46
	
	SS_HI;
 844:	2a 9a       	sbi	0x05, 2	; 5
	sei();
 846:	78 94       	sei
}
 848:	08 95       	ret

0000084a <timer_init>:

void timer_init(void)
{
	// for 20.0000MHz clock
	// timer 0 is the 1mS (0.5mS?) tick
	TCCR0A  = (1<<WGM01);					// ctc mode
 84a:	82 e0       	ldi	r24, 0x02	; 2
 84c:	84 bd       	out	0x24, r24	; 36
	TCCR0B  = (1<<CS02); 					// divide by 256
 84e:	94 e0       	ldi	r25, 0x04	; 4
 850:	95 bd       	out	0x25, r25	; 37
	OCR0A   = 0x26;							// or 38 decimal -- 0.5mS
 852:	96 e2       	ldi	r25, 0x26	; 38
 854:	97 bd       	out	0x27, r25	; 39
	TIMSK0	= 1<<OCIE0A;					// output compare A match irq
 856:	80 93 6e 00 	sts	0x006E, r24	; 0x80006e <__TEXT_REGION_LENGTH__+0x7e006e>
}
 85a:	08 95       	ret

0000085c <__vector_21>:


//	ADC interrupt
ISR(ADC_vect)
{
 85c:	1f 92       	push	r1
 85e:	0f 92       	push	r0
 860:	0f b6       	in	r0, 0x3f	; 63
 862:	0f 92       	push	r0
 864:	11 24       	eor	r1, r1
 866:	2f 93       	push	r18
 868:	3f 93       	push	r19
 86a:	4f 93       	push	r20
 86c:	5f 93       	push	r21
 86e:	6f 93       	push	r22
 870:	7f 93       	push	r23
 872:	8f 93       	push	r24
 874:	9f 93       	push	r25
 876:	af 93       	push	r26
 878:	bf 93       	push	r27
 87a:	ef 93       	push	r30
 87c:	ff 93       	push	r31
	//process results
	switch (thisAdcChannel) {
 87e:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <thisAdcChannel>
 882:	82 30       	cpi	r24, 0x02	; 2
 884:	09 f4       	brne	.+2      	; 0x888 <__vector_21+0x2c>
 886:	52 c0       	rjmp	.+164    	; 0x92c <__stack+0x2d>
 888:	88 f5       	brcc	.+98     	; 0x8ec <__vector_21+0x90>
 88a:	88 23       	and	r24, r24
 88c:	e9 f1       	breq	.+122    	; 0x908 <__stack+0x9>
 88e:	81 30       	cpi	r24, 0x01	; 1
 890:	09 f4       	brne	.+2      	; 0x894 <__vector_21+0x38>
 892:	43 c0       	rjmp	.+134    	; 0x91a <__stack+0x1b>
		rawAdcPots[2] = ADC;
		break;
		
	}
	// do the math
	adcProcess();
 894:	0e 94 88 03 	call	0x710	; 0x710 <adcProcess>
	//set up for next channel
	thisAdcChannel+=1;
 898:	80 91 2f 01 	lds	r24, 0x012F	; 0x80012f <thisAdcChannel>
 89c:	8f 5f       	subi	r24, 0xFF	; 255
	if(thisAdcChannel >= ADCCHANNELMAX)
 89e:	86 30       	cpi	r24, 0x06	; 6
 8a0:	08 f0       	brcs	.+2      	; 0x8a4 <__vector_21+0x48>
 8a2:	5f c0       	rjmp	.+190    	; 0x962 <__stack+0x63>
		
	}
	// do the math
	adcProcess();
	//set up for next channel
	thisAdcChannel+=1;
 8a4:	80 93 2f 01 	sts	0x012F, r24	; 0x80012f <thisAdcChannel>
	if(thisAdcChannel >= ADCCHANNELMAX)
	thisAdcChannel=0;
	ADMUX &= 0xF0;
 8a8:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
 8ac:	80 7f       	andi	r24, 0xF0	; 240
 8ae:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADMUX |= thisAdcChannel;
 8b2:	80 91 7c 00 	lds	r24, 0x007C	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
 8b6:	90 91 2f 01 	lds	r25, 0x012F	; 0x80012f <thisAdcChannel>
 8ba:	89 2b       	or	r24, r25
 8bc:	80 93 7c 00 	sts	0x007C, r24	; 0x80007c <__TEXT_REGION_LENGTH__+0x7e007c>
	ADCSRA |= (1<<ADSC);				//start next conversion
 8c0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 8c4:	80 64       	ori	r24, 0x40	; 64
 8c6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
}
 8ca:	ff 91       	pop	r31
 8cc:	ef 91       	pop	r30
 8ce:	bf 91       	pop	r27
 8d0:	af 91       	pop	r26
 8d2:	9f 91       	pop	r25
 8d4:	8f 91       	pop	r24
 8d6:	7f 91       	pop	r23
 8d8:	6f 91       	pop	r22
 8da:	5f 91       	pop	r21
 8dc:	4f 91       	pop	r20
 8de:	3f 91       	pop	r19
 8e0:	2f 91       	pop	r18
 8e2:	0f 90       	pop	r0
 8e4:	0f be       	out	0x3f, r0	; 63
 8e6:	0f 90       	pop	r0
 8e8:	1f 90       	pop	r1
 8ea:	18 95       	reti

//	ADC interrupt
ISR(ADC_vect)
{
	//process results
	switch (thisAdcChannel) {
 8ec:	84 30       	cpi	r24, 0x04	; 4
 8ee:	81 f1       	breq	.+96     	; 0x950 <__stack+0x51>
 8f0:	30 f1       	brcs	.+76     	; 0x93e <__stack+0x3f>
 8f2:	85 30       	cpi	r24, 0x05	; 5
 8f4:	79 f6       	brne	.-98     	; 0x894 <__vector_21+0x38>
		break;
		case 4:
		rawAdcPots[3] = ADC;
		break;
		case 5:
		rawAdcPots[2] = ADC;
 8f6:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 8fa:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 8fe:	90 93 2c 01 	sts	0x012C, r25	; 0x80012c <rawAdcPots+0x5>
 902:	80 93 2b 01 	sts	0x012B, r24	; 0x80012b <rawAdcPots+0x4>
		break;
 906:	c6 cf       	rjmp	.-116    	; 0x894 <__vector_21+0x38>
ISR(ADC_vect)
{
	//process results
	switch (thisAdcChannel) {
		case 0:
		rel_cv = ADC;
 908:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 90c:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 910:	90 93 26 01 	sts	0x0126, r25	; 0x800126 <rel_cv+0x1>
 914:	80 93 25 01 	sts	0x0125, r24	; 0x800125 <rel_cv>
		break;
 918:	bd cf       	rjmp	.-134    	; 0x894 <__vector_21+0x38>
		case 1:
		adsr_cv = ADC;
 91a:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 91e:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 922:	90 93 39 01 	sts	0x0139, r25	; 0x800139 <adsr_cv+0x1>
 926:	80 93 38 01 	sts	0x0138, r24	; 0x800138 <adsr_cv>
		break;
 92a:	b4 cf       	rjmp	.-152    	; 0x894 <__vector_21+0x38>
		case 2:
		rawAdcPots[1] = ADC;
 92c:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 930:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 934:	90 93 2a 01 	sts	0x012A, r25	; 0x80012a <rawAdcPots+0x3>
 938:	80 93 29 01 	sts	0x0129, r24	; 0x800129 <rawAdcPots+0x2>
		break;
 93c:	ab cf       	rjmp	.-170    	; 0x894 <__vector_21+0x38>
		case 3:
		rawAdcPots[0] = ADC;
 93e:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 942:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 946:	90 93 28 01 	sts	0x0128, r25	; 0x800128 <rawAdcPots+0x1>
 94a:	80 93 27 01 	sts	0x0127, r24	; 0x800127 <rawAdcPots>
		break;
 94e:	a2 cf       	rjmp	.-188    	; 0x894 <__vector_21+0x38>
		case 4:
		rawAdcPots[3] = ADC;
 950:	80 91 78 00 	lds	r24, 0x0078	; 0x800078 <__TEXT_REGION_LENGTH__+0x7e0078>
 954:	90 91 79 00 	lds	r25, 0x0079	; 0x800079 <__TEXT_REGION_LENGTH__+0x7e0079>
 958:	90 93 2e 01 	sts	0x012E, r25	; 0x80012e <rawAdcPots+0x7>
 95c:	80 93 2d 01 	sts	0x012D, r24	; 0x80012d <rawAdcPots+0x6>
		break;
 960:	99 cf       	rjmp	.-206    	; 0x894 <__vector_21+0x38>
	// do the math
	adcProcess();
	//set up for next channel
	thisAdcChannel+=1;
	if(thisAdcChannel >= ADCCHANNELMAX)
	thisAdcChannel=0;
 962:	10 92 2f 01 	sts	0x012F, r1	; 0x80012f <thisAdcChannel>
 966:	a0 cf       	rjmp	.-192    	; 0x8a8 <__vector_21+0x4c>

00000968 <__vector_14>:
	ADCSRA |= (1<<ADSC);				//start next conversion
}


ISR (TIMER0_COMPA_vect)
{
 968:	1f 92       	push	r1
 96a:	0f 92       	push	r0
 96c:	0f b6       	in	r0, 0x3f	; 63
 96e:	0f 92       	push	r0
 970:	11 24       	eor	r1, r1
 972:	8f 93       	push	r24
	// end of cycle timer
	// terminates pulse began at end of release
	// width ~10mS
	if(flgEOC){
 974:	80 91 21 01 	lds	r24, 0x0121	; 0x800121 <flgEOC>
 978:	88 23       	and	r24, r24
 97a:	61 f0       	breq	.+24     	; 0x994 <__vector_14+0x2c>
		tmrEOC++;
 97c:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <tmrEOC>
 980:	8f 5f       	subi	r24, 0xFF	; 255
 982:	80 93 23 01 	sts	0x0123, r24	; 0x800123 <tmrEOC>
		if(tmrEOC>=EOC_TIMEOUT) {
 986:	80 91 23 01 	lds	r24, 0x0123	; 0x800123 <tmrEOC>
 98a:	89 30       	cpi	r24, 0x09	; 9
 98c:	18 f0       	brcs	.+6      	; 0x994 <__vector_14+0x2c>
			EOC_LO;
 98e:	29 98       	cbi	0x05, 1	; 5
			flgEOC=0;
 990:	10 92 21 01 	sts	0x0121, r1	; 0x800121 <flgEOC>
		}
	}

	flgProcess=1;
 994:	81 e0       	ldi	r24, 0x01	; 1
 996:	80 93 20 01 	sts	0x0120, r24	; 0x800120 <flgProcess>
}
 99a:	8f 91       	pop	r24
 99c:	0f 90       	pop	r0
 99e:	0f be       	out	0x3f, r0	; 63
 9a0:	0f 90       	pop	r0
 9a2:	1f 90       	pop	r1
 9a4:	18 95       	reti

000009a6 <__vector_5>:


ISR(PCINT2_vect)
{
 9a6:	1f 92       	push	r1
 9a8:	0f 92       	push	r0
 9aa:	0f b6       	in	r0, 0x3f	; 63
 9ac:	0f 92       	push	r0
 9ae:	11 24       	eor	r1, r1
 9b0:	8f 93       	push	r24
 9b2:	9f 93       	push	r25
	
	// processes Gate interrupt
	// uses pinDmem to remember old state to check for change
	// and to detect falling edge (Gate is inverted in hardware)
	
	pinDstate=PIND;					//get the state of PIND once	
 9b4:	89 b1       	in	r24, 0x09	; 9
	if((pinDstate&0x10)!=(pinDmem&0x10)) {		//did it change?
 9b6:	90 91 00 01 	lds	r25, 0x0100	; 0x800100 <__data_start>
 9ba:	98 27       	eor	r25, r24
 9bc:	94 ff       	sbrs	r25, 4
 9be:	05 c0       	rjmp	.+10     	; 0x9ca <__vector_5+0x24>
		if((pinDstate&0x10)==0x00)	{			//is it our edge?
 9c0:	84 fd       	sbrc	r24, 4
 9c2:	03 c0       	rjmp	.+6      	; 0x9ca <__vector_5+0x24>
			flgGate=1;
 9c4:	91 e0       	ldi	r25, 0x01	; 1
 9c6:	90 93 3a 01 	sts	0x013A, r25	; 0x80013a <flgGate>
		}
	}
	
	pinDmem=pinDstate;					//remember this port sample
 9ca:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
}
 9ce:	9f 91       	pop	r25
 9d0:	8f 91       	pop	r24
 9d2:	0f 90       	pop	r0
 9d4:	0f be       	out	0x3f, r0	; 63
 9d6:	0f 90       	pop	r0
 9d8:	1f 90       	pop	r1
 9da:	18 95       	reti

000009dc <main>:
uint8_t		flgProcess;					// shows its time to process the ADSR
volatile uint8_t		flgEOC,tmrEOC;

int main(void)
{
	cli();
 9dc:	f8 94       	cli
	init_ports();
 9de:	0e 94 53 00 	call	0xa6	; 0xa6 <init_ports>
	init_devices();
 9e2:	0e 94 6e 03 	call	0x6dc	; 0x6dc <init_devices>
	timer_init();
 9e6:	0e 94 25 04 	call	0x84a	; 0x84a <timer_init>
	pgm_init();
 9ea:	0e 94 7d 03 	call	0x6fa	; 0x6fa <pgm_init>
	sei();
 9ee:	78 94       	sei
	
	ADCSRA |= (1<<ADIE);					// enable ADC interrupts
 9f0:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 9f4:	88 60       	ori	r24, 0x08	; 8
 9f6:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
	ADCSRA |= (1<<ADSC);				//start next conversion
 9fa:	80 91 7a 00 	lds	r24, 0x007A	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
 9fe:	80 64       	ori	r24, 0x40	; 64
 a00:	80 93 7a 00 	sts	0x007A, r24	; 0x80007a <__TEXT_REGION_LENGTH__+0x7e007a>
		// wait for gate flag
		if(flgGate)
		{
			flgGate=0;			// clear flag
			LED_ATTACK
			thisADSR.state = s_att;
 a04:	c1 e0       	ldi	r28, 0x01	; 1
	ADCSRA |= (1<<ADSC);				//start next conversion

	while(1)
	{
		// wait for gate flag
		if(flgGate)
 a06:	80 91 3a 01 	lds	r24, 0x013A	; 0x80013a <flgGate>
 a0a:	88 23       	and	r24, r24
 a0c:	41 f0       	breq	.+16     	; 0xa1e <main+0x42>
		{
			flgGate=0;			// clear flag
 a0e:	10 92 3a 01 	sts	0x013A, r1	; 0x80013a <flgGate>
			LED_ATTACK
 a12:	8b b1       	in	r24, 0x0b	; 11
 a14:	8f 60       	ori	r24, 0x0F	; 15
 a16:	8b b9       	out	0x0b, r24	; 11
 a18:	58 98       	cbi	0x0b, 0	; 11
			thisADSR.state = s_att;
 a1a:	c0 93 1f 01 	sts	0x011F, r28	; 0x80011f <thisADSR+0x18>
		}
		// wait for processing flag
		// decouples from the irq so the processing does not happen
		// inside an irq.
		if(flgProcess)
 a1e:	80 91 20 01 	lds	r24, 0x0120	; 0x800120 <flgProcess>
 a22:	88 23       	and	r24, r24
 a24:	81 f3       	breq	.-32     	; 0xa06 <main+0x2a>
		{
			flgProcess=0;			// clear flag
 a26:	10 92 20 01 	sts	0x0120, r1	; 0x800120 <flgProcess>
			// set env based on switch
			if(SW_AR)
 a2a:	4f 9b       	sbis	0x09, 7	; 9
 a2c:	14 c0       	rjmp	.+40     	; 0xa56 <main+0x7a>
				flgAR=0;		// adsr
 a2e:	10 92 24 01 	sts	0x0124, r1	; 0x800124 <flgAR>
			else
				flgAR=1;		//ar
			if(flgARold!=flgAR)
 a32:	80 91 24 01 	lds	r24, 0x0124	; 0x800124 <flgAR>
 a36:	90 91 22 01 	lds	r25, 0x0122	; 0x800122 <flgARold>
 a3a:	98 13       	cpse	r25, r24
				thisADSR.state = s_att;
 a3c:	c0 93 1f 01 	sts	0x011F, r28	; 0x80011f <thisADSR+0x18>
			flgARold=flgAR;
 a40:	80 93 22 01 	sts	0x0122, r24	; 0x800122 <flgARold>
			
			// set shape based on switch
			if(SW_LIN)
 a44:	4e 9b       	sbis	0x09, 6	; 9
 a46:	0a c0       	rjmp	.+20     	; 0xa5c <main+0x80>
				flgShape=0;		// expo
 a48:	10 92 06 01 	sts	0x0106, r1	; 0x800106 <flgShape>
			else
				flgShape=1;		// lin			
			process_adsr();
 a4c:	0e 94 5b 00 	call	0xb6	; 0xb6 <process_adsr>
			SendToShiftyTypes();
 a50:	0e 94 06 04 	call	0x80c	; 0x80c <SendToShiftyTypes>
 a54:	d8 cf       	rjmp	.-80     	; 0xa06 <main+0x2a>
			flgProcess=0;			// clear flag
			// set env based on switch
			if(SW_AR)
				flgAR=0;		// adsr
			else
				flgAR=1;		//ar
 a56:	c0 93 24 01 	sts	0x0124, r28	; 0x800124 <flgAR>
 a5a:	eb cf       	rjmp	.-42     	; 0xa32 <main+0x56>
			
			// set shape based on switch
			if(SW_LIN)
				flgShape=0;		// expo
			else
				flgShape=1;		// lin			
 a5c:	c0 93 06 01 	sts	0x0106, r28	; 0x800106 <flgShape>
 a60:	f5 cf       	rjmp	.-22     	; 0xa4c <main+0x70>

00000a62 <__udivmodsi4>:
 a62:	a1 e2       	ldi	r26, 0x21	; 33
 a64:	1a 2e       	mov	r1, r26
 a66:	aa 1b       	sub	r26, r26
 a68:	bb 1b       	sub	r27, r27
 a6a:	fd 01       	movw	r30, r26
 a6c:	0d c0       	rjmp	.+26     	; 0xa88 <__udivmodsi4_ep>

00000a6e <__udivmodsi4_loop>:
 a6e:	aa 1f       	adc	r26, r26
 a70:	bb 1f       	adc	r27, r27
 a72:	ee 1f       	adc	r30, r30
 a74:	ff 1f       	adc	r31, r31
 a76:	a2 17       	cp	r26, r18
 a78:	b3 07       	cpc	r27, r19
 a7a:	e4 07       	cpc	r30, r20
 a7c:	f5 07       	cpc	r31, r21
 a7e:	20 f0       	brcs	.+8      	; 0xa88 <__udivmodsi4_ep>
 a80:	a2 1b       	sub	r26, r18
 a82:	b3 0b       	sbc	r27, r19
 a84:	e4 0b       	sbc	r30, r20
 a86:	f5 0b       	sbc	r31, r21

00000a88 <__udivmodsi4_ep>:
 a88:	66 1f       	adc	r22, r22
 a8a:	77 1f       	adc	r23, r23
 a8c:	88 1f       	adc	r24, r24
 a8e:	99 1f       	adc	r25, r25
 a90:	1a 94       	dec	r1
 a92:	69 f7       	brne	.-38     	; 0xa6e <__udivmodsi4_loop>
 a94:	60 95       	com	r22
 a96:	70 95       	com	r23
 a98:	80 95       	com	r24
 a9a:	90 95       	com	r25
 a9c:	9b 01       	movw	r18, r22
 a9e:	ac 01       	movw	r20, r24
 aa0:	bd 01       	movw	r22, r26
 aa2:	cf 01       	movw	r24, r30
 aa4:	08 95       	ret

00000aa6 <__divmodsi4>:
 aa6:	05 2e       	mov	r0, r21
 aa8:	97 fb       	bst	r25, 7
 aaa:	1e f4       	brtc	.+6      	; 0xab2 <__divmodsi4+0xc>
 aac:	00 94       	com	r0
 aae:	0e 94 6a 05 	call	0xad4	; 0xad4 <__negsi2>
 ab2:	57 fd       	sbrc	r21, 7
 ab4:	07 d0       	rcall	.+14     	; 0xac4 <__divmodsi4_neg2>
 ab6:	0e 94 31 05 	call	0xa62	; 0xa62 <__udivmodsi4>
 aba:	07 fc       	sbrc	r0, 7
 abc:	03 d0       	rcall	.+6      	; 0xac4 <__divmodsi4_neg2>
 abe:	4e f4       	brtc	.+18     	; 0xad2 <__divmodsi4_exit>
 ac0:	0c 94 6a 05 	jmp	0xad4	; 0xad4 <__negsi2>

00000ac4 <__divmodsi4_neg2>:
 ac4:	50 95       	com	r21
 ac6:	40 95       	com	r20
 ac8:	30 95       	com	r19
 aca:	21 95       	neg	r18
 acc:	3f 4f       	sbci	r19, 0xFF	; 255
 ace:	4f 4f       	sbci	r20, 0xFF	; 255
 ad0:	5f 4f       	sbci	r21, 0xFF	; 255

00000ad2 <__divmodsi4_exit>:
 ad2:	08 95       	ret

00000ad4 <__negsi2>:
 ad4:	90 95       	com	r25
 ad6:	80 95       	com	r24
 ad8:	70 95       	com	r23
 ada:	61 95       	neg	r22
 adc:	7f 4f       	sbci	r23, 0xFF	; 255
 ade:	8f 4f       	sbci	r24, 0xFF	; 255
 ae0:	9f 4f       	sbci	r25, 0xFF	; 255
 ae2:	08 95       	ret

00000ae4 <__muluhisi3>:
 ae4:	0e 94 8f 05 	call	0xb1e	; 0xb1e <__umulhisi3>
 ae8:	a5 9f       	mul	r26, r21
 aea:	90 0d       	add	r25, r0
 aec:	b4 9f       	mul	r27, r20
 aee:	90 0d       	add	r25, r0
 af0:	a4 9f       	mul	r26, r20
 af2:	80 0d       	add	r24, r0
 af4:	91 1d       	adc	r25, r1
 af6:	11 24       	eor	r1, r1
 af8:	08 95       	ret

00000afa <__subdi3>:
 afa:	2a 19       	sub	r18, r10
 afc:	3b 09       	sbc	r19, r11
 afe:	4c 09       	sbc	r20, r12
 b00:	5d 09       	sbc	r21, r13
 b02:	6e 09       	sbc	r22, r14
 b04:	7f 09       	sbc	r23, r15
 b06:	80 0b       	sbc	r24, r16
 b08:	91 0b       	sbc	r25, r17
 b0a:	08 95       	ret

00000b0c <__cmpdi2>:
 b0c:	2a 15       	cp	r18, r10
 b0e:	3b 05       	cpc	r19, r11
 b10:	4c 05       	cpc	r20, r12
 b12:	5d 05       	cpc	r21, r13
 b14:	6e 05       	cpc	r22, r14
 b16:	7f 05       	cpc	r23, r15
 b18:	80 07       	cpc	r24, r16
 b1a:	91 07       	cpc	r25, r17
 b1c:	08 95       	ret

00000b1e <__umulhisi3>:
 b1e:	a2 9f       	mul	r26, r18
 b20:	b0 01       	movw	r22, r0
 b22:	b3 9f       	mul	r27, r19
 b24:	c0 01       	movw	r24, r0
 b26:	a3 9f       	mul	r26, r19
 b28:	70 0d       	add	r23, r0
 b2a:	81 1d       	adc	r24, r1
 b2c:	11 24       	eor	r1, r1
 b2e:	91 1d       	adc	r25, r1
 b30:	b2 9f       	mul	r27, r18
 b32:	70 0d       	add	r23, r0
 b34:	81 1d       	adc	r24, r1
 b36:	11 24       	eor	r1, r1
 b38:	91 1d       	adc	r25, r1
 b3a:	08 95       	ret

00000b3c <_exit>:
 b3c:	f8 94       	cli

00000b3e <__stop_program>:
 b3e:	ff cf       	rjmp	.-2      	; 0xb3e <__stop_program>
